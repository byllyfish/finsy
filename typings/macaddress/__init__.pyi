"""
This type stub file was generated by pyright.
"""

"""Like ``ipaddress``, but for hardware identifiers such as MAC addresses."""
__all__ = ('HWAddress', 'OUI', 'CDI32', 'CDI40', 'MAC', 'EUI48', 'EUI60', 'EUI64', 'parse')
__version__ = ...
_HEX_DIGITS = ...
class HWAddress:
    """Base class for hardware addresses.

    Can be subclassed to create new address types
    by just defining a couple class attribures.

    Attributes:
        size: An integer defined by each subclass to specify the size
            (in bits) of the hardware address.
        formats: A sequence of format strings defined by each subclass
            to specify what formats the class can parse. The first
            format string is also used for ``repr`` and ``str`` output.
            Each "x" in each format string stands for one hexadecimal
            digit. All other characters are literal. For example, for
            MAC addresses, the format strings are "xx-xx-xx-xx-xx-xx",
            "xx:xx:xx:xx:xx:xx", "xxxx.xxxx.xxxx", and "xxxxxxxxxxxx".
    """
    __slots__ = ...
    def __init__(self, address) -> None:
        """Initialize the hardware address object with the address given.

        Arguments:
            address: An ``int``, ``bytes``, or ``str`` representation
                of the address, or another instance of the same class
                of address. If a string, the ``formats`` attribute of
                the class is used to parse it. If a byte string, it
                is read in big-endian. If an integer, its value bytes
                in big-endian are used as the address bytes. If an
                instance of the same address class, its value is used.

        Raises:
            TypeError: If ``address`` is not one of the valid types.
            ValueError: If ``address`` is a string but does not match
                one of the formats, if ``address`` is a byte string
                but does not match the size, or if ``address`` is an
                integer with a value that is negative or too big.
        """
        ...
    
    def __repr__(self): # -> Any:
        """Represent the hardware address as an unambiguous string."""
        ...
    
    def __str__(self) -> str:
        """Get the canonical human-readable string of this hardware address."""
        ...
    
    def __bytes__(self):
        """Get the big-endian byte string of this hardware address."""
        ...
    
    def __int__(self) -> int:
        """Get the raw integer value of this hardware address."""
        ...
    
    def __eq__(self, other) -> bool:
        """Check if this hardware address is equal to another.

        They are equal if they are instances of the same class,
        have the same size, and their addresses are equal.
        """
        ...
    
    def __ne__(self, other) -> bool:
        """Check if this hardware address is not equal to another."""
        ...
    
    def __lt__(self, other) -> bool:
        """Check if this hardware address is before another.

        Hardware addresses are sorted by their raw bit strings,
        regardless of the exact hardware address class or size.

        For example: ``OUI('00-00-00') < CDI32('00-00-00-00')``,
        and they both are less than ``OUI('00-00-01')``.

        This order intuitively groups address prefixes like OUIs
        with (and just in front of) addresses like MAC addresses
        which have that prefix when sorting a list of them.
        """
        ...
    
    def __le__(self, other) -> bool:
        """Check if this hardware address is before or equal to another."""
        ...
    
    def __gt__(self, other) -> bool:
        """Check if this hardware address is after another."""
        ...
    
    def __ge__(self, other) -> bool:
        """Check if this hardware address is after or equal to another."""
        ...
    
    def __hash__(self) -> int:
        """Get the hash of this hardware address."""
        ...
    


class OUI(HWAddress):
    """Organizationally Unique Identifier."""
    __slots__ = ...
    size = ...
    formats = ...


class _StartsWithOUI(HWAddress):
    __slots__ = ...
    @property
    def oui(self): # -> OUI:
        """Get the OUI part of this hardware address."""
        ...
    


class CDI32(_StartsWithOUI):
    """32-bit Context Dependent Identifier (CDI-32)."""
    __slots__ = ...
    size = ...
    formats = ...


class CDI40(_StartsWithOUI):
    """40-bit Context Dependent Identifier (CDI-40)."""
    __slots__ = ...
    size = ...
    formats = ...


class EUI48(_StartsWithOUI):
    """48-Bit Extended Unique Identifier (EUI-48).

    EUI-48 is also the modern official name for what
    many people are used to calling a "MAC address".
    """
    __slots__ = ...
    size = ...
    formats = ...


class MAC(EUI48):
    """MAC address. A subclass of EUI48.

    There is nothing wrong with using EUI48 for MAC addresses,
    this is just provided as a convenience for the many users
    who will look for "MAC address" without knowing about EUI.

    But it is a subclass instead of just an alias because it
    might be nice in some situations to distinguish in code
    between MAC addresses and other uses of EUI-48.
    """
    __slots__ = ...


class EUI60(_StartsWithOUI):
    """60-Bit Extended Unique Identifier (EUI-60)."""
    __slots__ = ...
    size = ...
    formats = ...


class EUI64(_StartsWithOUI):
    """64-Bit Extended Unique Identifier (EUI-64)."""
    __slots__ = ...
    size = ...
    formats = ...


def parse(value, *classes):
    """Try parsing a value as several hardware address classes at once.

    This lets you just write

        address = hwaddress.parse(user_input, EUI64, EUI48, ...)

    instead of all of this:

        try:
            address = hwaddress.EUI64(user_input)
        except ValueError:
            try:
                address = hwaddress.EUI48(user_input)
            except ValueError:
                ...

    Arguments:
        value: The value to parse as a hardware address. Either a
            string, byte string, or an instance of one of the classes.
        *classes: HWAddress subclasses to try to parse the string as.
            If the input address could parse as more than one of the
            classes, it is parsed as the first one.

    Returns:
        HWAddress: The parsed hardware address if the value argument
            was a string or byte string, or the value argument itself
            if it was already an instance of one of the classes.

    Raises:
        TypeError: If the value is not one of the valid types,
            or if no classes were passed in.
        ValueError: If the value could not be parsed as any
            of the given classes.
    """
    ...

