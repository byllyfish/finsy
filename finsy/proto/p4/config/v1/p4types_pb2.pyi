"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class P4TypeInfo(google.protobuf.message.Message):
    """P4 type specs ---------------------------------------------------------------

    From the P4_16 spec:

    |--------------------|--------------------------------------------|
    |                    | Container type                             |
    | Element type       |-----------|--------------|-----------------|
    |                    | header    | header_union | struct or tuple |
    |--------------------|-----------|--------------|-----------------|
    | bit<W>             | allowed   | error        | allowed         |
    | int<W>             | allowed   | error        | allowed         |
    | varbit<W>          | allowed   | error        | allowed         |
    | int                | error     | error        | error           |
    | void               | error     | error        | error           |
    | error              | error     | error        | allowed         |
    | match_kind         | error     | error        | error           |
    | bool               | error     | error        | allowed         |
    | enum               | allowed*  | error        | allowed         |
    | header             | error     | allowed      | allowed         |
    | header stack       | error     | error        | allowed         |
    | header_union       | error     | error        | allowed         |
    | struct             | error     | error        | allowed         |
    | tuple              | error     | error        | allowed         |
    |--------------------|-----------|--------------|-----------------|

    *if serializable

    These P4 types (struct, header_type, header_union and enum) are guaranteed to
    have a fully-qualified name (e.g. you cannot use an anonymous struct to
    declare a variable like in C). Instead of duplicating the type spec for these
    every time the type is used, we include the type spec once in this P4TypeInfo
    message and refer to the types by name in the P4DataTypeSpec message. We also
    support annotations for these type specs which can be useful, e.g. to
    identify well-known headers (such as ipv4).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class StructsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___P4StructTypeSpec: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___P4StructTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___P4HeaderTypeSpec: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___P4HeaderTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class HeaderUnionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___P4HeaderUnionTypeSpec: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___P4HeaderUnionTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class EnumsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___P4EnumTypeSpec: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___P4EnumTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class SerializableEnumsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___P4SerializableEnumTypeSpec: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___P4SerializableEnumTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class NewTypesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___P4NewTypeSpec: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___P4NewTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    STRUCTS_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    HEADER_UNIONS_FIELD_NUMBER: builtins.int
    ENUMS_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    SERIALIZABLE_ENUMS_FIELD_NUMBER: builtins.int
    NEW_TYPES_FIELD_NUMBER: builtins.int
    @property
    def structs(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___P4StructTypeSpec]: ...
    @property
    def headers(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___P4HeaderTypeSpec]: ...
    @property
    def header_unions(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___P4HeaderUnionTypeSpec]: ...
    @property
    def enums(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___P4EnumTypeSpec]: ...
    @property
    def error(self) -> global___P4ErrorTypeSpec: ...
    @property
    def serializable_enums(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___P4SerializableEnumTypeSpec]: ...
    @property
    def new_types(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___P4NewTypeSpec]: ...
    def __init__(self,
        *,
        structs: typing.Optional[typing.Mapping[typing.Text, global___P4StructTypeSpec]] = ...,
        headers: typing.Optional[typing.Mapping[typing.Text, global___P4HeaderTypeSpec]] = ...,
        header_unions: typing.Optional[typing.Mapping[typing.Text, global___P4HeaderUnionTypeSpec]] = ...,
        enums: typing.Optional[typing.Mapping[typing.Text, global___P4EnumTypeSpec]] = ...,
        error: typing.Optional[global___P4ErrorTypeSpec] = ...,
        serializable_enums: typing.Optional[typing.Mapping[typing.Text, global___P4SerializableEnumTypeSpec]] = ...,
        new_types: typing.Optional[typing.Mapping[typing.Text, global___P4NewTypeSpec]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["error",b"error"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["enums",b"enums","error",b"error","header_unions",b"header_unions","headers",b"headers","new_types",b"new_types","serializable_enums",b"serializable_enums","structs",b"structs"]) -> None: ...
global___P4TypeInfo = P4TypeInfo

class P4DataTypeSpec(google.protobuf.message.Message):
    """Describes a P4_16 type."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BITSTRING_FIELD_NUMBER: builtins.int
    BOOL_FIELD_NUMBER: builtins.int
    TUPLE_FIELD_NUMBER: builtins.int
    STRUCT_FIELD_NUMBER: builtins.int
    HEADER_FIELD_NUMBER: builtins.int
    HEADER_UNION_FIELD_NUMBER: builtins.int
    HEADER_STACK_FIELD_NUMBER: builtins.int
    HEADER_UNION_STACK_FIELD_NUMBER: builtins.int
    ENUM_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    SERIALIZABLE_ENUM_FIELD_NUMBER: builtins.int
    NEW_TYPE_FIELD_NUMBER: builtins.int
    @property
    def bitstring(self) -> global___P4BitstringLikeTypeSpec: ...
    @property
    def bool(self) -> global___P4BoolType: ...
    @property
    def tuple(self) -> global___P4TupleTypeSpec: ...
    @property
    def struct(self) -> global___P4NamedType: ...
    @property
    def header(self) -> global___P4NamedType: ...
    @property
    def header_union(self) -> global___P4NamedType: ...
    @property
    def header_stack(self) -> global___P4HeaderStackTypeSpec: ...
    @property
    def header_union_stack(self) -> global___P4HeaderUnionStackTypeSpec: ...
    @property
    def enum(self) -> global___P4NamedType: ...
    @property
    def error(self) -> global___P4ErrorType: ...
    @property
    def serializable_enum(self) -> global___P4NamedType: ...
    @property
    def new_type(self) -> global___P4NamedType: ...
    def __init__(self,
        *,
        bitstring: typing.Optional[global___P4BitstringLikeTypeSpec] = ...,
        bool: typing.Optional[global___P4BoolType] = ...,
        tuple: typing.Optional[global___P4TupleTypeSpec] = ...,
        struct: typing.Optional[global___P4NamedType] = ...,
        header: typing.Optional[global___P4NamedType] = ...,
        header_union: typing.Optional[global___P4NamedType] = ...,
        header_stack: typing.Optional[global___P4HeaderStackTypeSpec] = ...,
        header_union_stack: typing.Optional[global___P4HeaderUnionStackTypeSpec] = ...,
        enum: typing.Optional[global___P4NamedType] = ...,
        error: typing.Optional[global___P4ErrorType] = ...,
        serializable_enum: typing.Optional[global___P4NamedType] = ...,
        new_type: typing.Optional[global___P4NamedType] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bitstring",b"bitstring","bool",b"bool","enum",b"enum","error",b"error","header",b"header","header_stack",b"header_stack","header_union",b"header_union","header_union_stack",b"header_union_stack","new_type",b"new_type","serializable_enum",b"serializable_enum","struct",b"struct","tuple",b"tuple","type_spec",b"type_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bitstring",b"bitstring","bool",b"bool","enum",b"enum","error",b"error","header",b"header","header_stack",b"header_stack","header_union",b"header_union","header_union_stack",b"header_union_stack","new_type",b"new_type","serializable_enum",b"serializable_enum","struct",b"struct","tuple",b"tuple","type_spec",b"type_spec"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type_spec",b"type_spec"]) -> typing.Optional[typing_extensions.Literal["bitstring","bool","tuple","struct","header","header_union","header_stack","header_union_stack","enum","error","serializable_enum","new_type"]]: ...
global___P4DataTypeSpec = P4DataTypeSpec

class P4NamedType(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text
    def __init__(self,
        *,
        name: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___P4NamedType = P4NamedType

class P4BoolType(google.protobuf.message.Message):
    """Empty message as no type information needed, just used as a placeholder in
    the oneof to identify boolean types.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___P4BoolType = P4BoolType

class P4ErrorType(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___P4ErrorType = P4ErrorType

class P4BitstringLikeTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BIT_FIELD_NUMBER: builtins.int
    INT_FIELD_NUMBER: builtins.int
    VARBIT_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def bit(self) -> global___P4BitTypeSpec:
        """bit<W>"""
        pass
    @property
    def int(self) -> global___P4IntTypeSpec:
        """int<W>"""
        pass
    @property
    def varbit(self) -> global___P4VarbitTypeSpec:
        """varbit<W>"""
        pass
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Useful to identify well-known types, such as IP address or Ethernet MAC
        address.
        """
        pass
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        bit: typing.Optional[global___P4BitTypeSpec] = ...,
        int: typing.Optional[global___P4IntTypeSpec] = ...,
        varbit: typing.Optional[global___P4VarbitTypeSpec] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bit",b"bit","int",b"int","type_spec",b"type_spec","varbit",b"varbit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","bit",b"bit","int",b"int","structured_annotations",b"structured_annotations","type_spec",b"type_spec","varbit",b"varbit"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type_spec",b"type_spec"]) -> typing.Optional[typing_extensions.Literal["bit","int","varbit"]]: ...
global___P4BitstringLikeTypeSpec = P4BitstringLikeTypeSpec

class P4BitTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BITWIDTH_FIELD_NUMBER: builtins.int
    bitwidth: builtins.int
    def __init__(self,
        *,
        bitwidth: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["bitwidth",b"bitwidth"]) -> None: ...
global___P4BitTypeSpec = P4BitTypeSpec

class P4IntTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BITWIDTH_FIELD_NUMBER: builtins.int
    bitwidth: builtins.int
    def __init__(self,
        *,
        bitwidth: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["bitwidth",b"bitwidth"]) -> None: ...
global___P4IntTypeSpec = P4IntTypeSpec

class P4VarbitTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    MAX_BITWIDTH_FIELD_NUMBER: builtins.int
    max_bitwidth: builtins.int
    def __init__(self,
        *,
        max_bitwidth: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_bitwidth",b"max_bitwidth"]) -> None: ...
global___P4VarbitTypeSpec = P4VarbitTypeSpec

class P4TupleTypeSpec(google.protobuf.message.Message):
    """From the P4_16 spec: "A tuple is similar to a struct, in that it holds
    multiple values. Unlike a struct type, tuples have no named fields."
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    MEMBERS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___P4DataTypeSpec]: ...
    def __init__(self,
        *,
        members: typing.Optional[typing.Iterable[global___P4DataTypeSpec]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["members",b"members"]) -> None: ...
global___P4TupleTypeSpec = P4TupleTypeSpec

class P4StructTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Member(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        TYPE_SPEC_FIELD_NUMBER: builtins.int
        name: typing.Text
        @property
        def type_spec(self) -> global___P4DataTypeSpec: ...
        def __init__(self,
            *,
            name: typing.Text = ...,
            type_spec: typing.Optional[global___P4DataTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type_spec",b"type_spec"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name","type_spec",b"type_spec"]) -> None: ...

    MEMBERS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___P4StructTypeSpec.Member]: ...
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        members: typing.Optional[typing.Iterable[global___P4StructTypeSpec.Member]] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","members",b"members","structured_annotations",b"structured_annotations"]) -> None: ...
global___P4StructTypeSpec = P4StructTypeSpec

class P4HeaderTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Member(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        TYPE_SPEC_FIELD_NUMBER: builtins.int
        name: typing.Text
        @property
        def type_spec(self) -> global___P4BitstringLikeTypeSpec: ...
        def __init__(self,
            *,
            name: typing.Text = ...,
            type_spec: typing.Optional[global___P4BitstringLikeTypeSpec] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type_spec",b"type_spec"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name","type_spec",b"type_spec"]) -> None: ...

    MEMBERS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___P4HeaderTypeSpec.Member]: ...
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        members: typing.Optional[typing.Iterable[global___P4HeaderTypeSpec.Member]] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","members",b"members","structured_annotations",b"structured_annotations"]) -> None: ...
global___P4HeaderTypeSpec = P4HeaderTypeSpec

class P4HeaderUnionTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Member(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        HEADER_FIELD_NUMBER: builtins.int
        name: typing.Text
        @property
        def header(self) -> global___P4NamedType: ...
        def __init__(self,
            *,
            name: typing.Text = ...,
            header: typing.Optional[global___P4NamedType] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["header",b"header","name",b"name"]) -> None: ...

    MEMBERS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___P4HeaderUnionTypeSpec.Member]: ...
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        members: typing.Optional[typing.Iterable[global___P4HeaderUnionTypeSpec.Member]] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","members",b"members","structured_annotations",b"structured_annotations"]) -> None: ...
global___P4HeaderUnionTypeSpec = P4HeaderUnionTypeSpec

class P4HeaderStackTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_FIELD_NUMBER: builtins.int
    SIZE_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> global___P4NamedType: ...
    size: builtins.int
    def __init__(self,
        *,
        header: typing.Optional[global___P4NamedType] = ...,
        size: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header",b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header",b"header","size",b"size"]) -> None: ...
global___P4HeaderStackTypeSpec = P4HeaderStackTypeSpec

class P4HeaderUnionStackTypeSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    HEADER_UNION_FIELD_NUMBER: builtins.int
    SIZE_FIELD_NUMBER: builtins.int
    @property
    def header_union(self) -> global___P4NamedType: ...
    size: builtins.int
    def __init__(self,
        *,
        header_union: typing.Optional[global___P4NamedType] = ...,
        size: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header_union",b"header_union"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["header_union",b"header_union","size",b"size"]) -> None: ...
global___P4HeaderUnionStackTypeSpec = P4HeaderUnionStackTypeSpec

class KeyValuePair(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    key: typing.Text
    @property
    def value(self) -> global___Expression: ...
    def __init__(self,
        *,
        key: typing.Text = ...,
        value: typing.Optional[global___Expression] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...
global___KeyValuePair = KeyValuePair

class KeyValuePairList(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    KV_PAIRS_FIELD_NUMBER: builtins.int
    @property
    def kv_pairs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___KeyValuePair]: ...
    def __init__(self,
        *,
        kv_pairs: typing.Optional[typing.Iterable[global___KeyValuePair]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["kv_pairs",b"kv_pairs"]) -> None: ...
global___KeyValuePairList = KeyValuePairList

class Expression(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STRING_VALUE_FIELD_NUMBER: builtins.int
    INT64_VALUE_FIELD_NUMBER: builtins.int
    BOOL_VALUE_FIELD_NUMBER: builtins.int
    string_value: typing.Text
    int64_value: builtins.int
    bool_value: builtins.bool
    def __init__(self,
        *,
        string_value: typing.Text = ...,
        int64_value: builtins.int = ...,
        bool_value: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bool_value",b"bool_value","int64_value",b"int64_value","string_value",b"string_value","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bool_value",b"bool_value","int64_value",b"int64_value","string_value",b"string_value","value",b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["value",b"value"]) -> typing.Optional[typing_extensions.Literal["string_value","int64_value","bool_value"]]: ...
global___Expression = Expression

class ExpressionList(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    EXPRESSIONS_FIELD_NUMBER: builtins.int
    @property
    def expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]: ...
    def __init__(self,
        *,
        expressions: typing.Optional[typing.Iterable[global___Expression]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["expressions",b"expressions"]) -> None: ...
global___ExpressionList = ExpressionList

class StructuredAnnotation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    EXPRESSION_LIST_FIELD_NUMBER: builtins.int
    KV_PAIR_LIST_FIELD_NUMBER: builtins.int
    SOURCE_LOCATION_FIELD_NUMBER: builtins.int
    name: typing.Text
    @property
    def expression_list(self) -> global___ExpressionList: ...
    @property
    def kv_pair_list(self) -> global___KeyValuePairList: ...
    @property
    def source_location(self) -> global___SourceLocation:
        """Optional. Location of the '@' symbol of this annotation in the source code."""
        pass
    def __init__(self,
        *,
        name: typing.Text = ...,
        expression_list: typing.Optional[global___ExpressionList] = ...,
        kv_pair_list: typing.Optional[global___KeyValuePairList] = ...,
        source_location: typing.Optional[global___SourceLocation] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["body",b"body","expression_list",b"expression_list","kv_pair_list",b"kv_pair_list","source_location",b"source_location"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["body",b"body","expression_list",b"expression_list","kv_pair_list",b"kv_pair_list","name",b"name","source_location",b"source_location"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["body",b"body"]) -> typing.Optional[typing_extensions.Literal["expression_list","kv_pair_list"]]: ...
global___StructuredAnnotation = StructuredAnnotation

class SourceLocation(google.protobuf.message.Message):
    """Location of code relative to a given source file."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    FILE_FIELD_NUMBER: builtins.int
    LINE_FIELD_NUMBER: builtins.int
    COLUMN_FIELD_NUMBER: builtins.int
    file: typing.Text
    """Path to the source file (absolute or relative to the working directory)."""

    line: builtins.int
    """Line and column numbers within the source file, 1-based."""

    column: builtins.int
    def __init__(self,
        *,
        file: typing.Text = ...,
        line: builtins.int = ...,
        column: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["column",b"column","file",b"file","line",b"line"]) -> None: ...
global___SourceLocation = SourceLocation

class P4EnumTypeSpec(google.protobuf.message.Message):
    """For "safe" enums with no underlying representation and no member integer
    values.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Member(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        ANNOTATIONS_FIELD_NUMBER: builtins.int
        ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
        STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
        name: typing.Text
        @property
        def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
        @property
        def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
            """Optional. If present, the location of `annotations[i]` is given by
            `annotation_locations[i]`.
            """
            pass
        @property
        def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
        def __init__(self,
            *,
            name: typing.Text = ...,
            annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
            annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
            structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","name",b"name","structured_annotations",b"structured_annotations"]) -> None: ...

    MEMBERS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___P4EnumTypeSpec.Member]: ...
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        members: typing.Optional[typing.Iterable[global___P4EnumTypeSpec.Member]] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","members",b"members","structured_annotations",b"structured_annotations"]) -> None: ...
global___P4EnumTypeSpec = P4EnumTypeSpec

class P4SerializableEnumTypeSpec(google.protobuf.message.Message):
    """For serializable (or "unsafe") enums, which have an underlying type. Note
    that as per the P4_16 specification, the underlying representation can only
    be a bit<W> type.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Member(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        ANNOTATIONS_FIELD_NUMBER: builtins.int
        ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
        STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
        name: typing.Text
        value: builtins.bytes
        @property
        def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
        @property
        def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
            """Optional. If present, the location of `annotations[i]` is given by
            `annotation_locations[i]`.
            """
            pass
        @property
        def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
        def __init__(self,
            *,
            name: typing.Text = ...,
            value: builtins.bytes = ...,
            annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
            annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
            structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","name",b"name","structured_annotations",b"structured_annotations","value",b"value"]) -> None: ...

    UNDERLYING_TYPE_FIELD_NUMBER: builtins.int
    MEMBERS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def underlying_type(self) -> global___P4BitTypeSpec: ...
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___P4SerializableEnumTypeSpec.Member]: ...
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        underlying_type: typing.Optional[global___P4BitTypeSpec] = ...,
        members: typing.Optional[typing.Iterable[global___P4SerializableEnumTypeSpec.Member]] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["underlying_type",b"underlying_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","members",b"members","structured_annotations",b"structured_annotations","underlying_type",b"underlying_type"]) -> None: ...
global___P4SerializableEnumTypeSpec = P4SerializableEnumTypeSpec

class P4ErrorTypeSpec(google.protobuf.message.Message):
    """Similar to an enum, but there is always one and only one instance per P4
    program.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    MEMBERS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    def __init__(self,
        *,
        members: typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["members",b"members"]) -> None: ...
global___P4ErrorTypeSpec = P4ErrorTypeSpec

class P4NewTypeTranslation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class SdnString(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        def __init__(self,
            ) -> None: ...

    URI_FIELD_NUMBER: builtins.int
    SDN_BITWIDTH_FIELD_NUMBER: builtins.int
    SDN_STRING_FIELD_NUMBER: builtins.int
    uri: typing.Text
    """the URI uniquely identifies the translation in order to enable the
    P4Runtime agent to perform value-mapping appropriately when required. It is
    recommended that the URI includes at least the P4 architecture name and the
    type name.
    """

    sdn_bitwidth: builtins.int
    @property
    def sdn_string(self) -> global___P4NewTypeTranslation.SdnString: ...
    def __init__(self,
        *,
        uri: typing.Text = ...,
        sdn_bitwidth: builtins.int = ...,
        sdn_string: typing.Optional[global___P4NewTypeTranslation.SdnString] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["sdn_bitwidth",b"sdn_bitwidth","sdn_string",b"sdn_string","sdn_type",b"sdn_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["sdn_bitwidth",b"sdn_bitwidth","sdn_string",b"sdn_string","sdn_type",b"sdn_type","uri",b"uri"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["sdn_type",b"sdn_type"]) -> typing.Optional[typing_extensions.Literal["sdn_bitwidth","sdn_string"]]: ...
global___P4NewTypeTranslation = P4NewTypeTranslation

class P4NewTypeSpec(google.protobuf.message.Message):
    """New types introduced with the "type" keyword"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ORIGINAL_TYPE_FIELD_NUMBER: builtins.int
    TRANSLATED_TYPE_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    ANNOTATION_LOCATIONS_FIELD_NUMBER: builtins.int
    STRUCTURED_ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def original_type(self) -> global___P4DataTypeSpec:
        """if no @p4runtime_translation annotation present"""
        pass
    @property
    def translated_type(self) -> global___P4NewTypeTranslation:
        """if @p4runtime_translation annotation present"""
        pass
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """for other annotations (not @p4runtime_translation)"""
        pass
    @property
    def annotation_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SourceLocation]:
        """Optional. If present, the location of `annotations[i]` is given by
        `annotation_locations[i]`.
        """
        pass
    @property
    def structured_annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructuredAnnotation]: ...
    def __init__(self,
        *,
        original_type: typing.Optional[global___P4DataTypeSpec] = ...,
        translated_type: typing.Optional[global___P4NewTypeTranslation] = ...,
        annotations: typing.Optional[typing.Iterable[typing.Text]] = ...,
        annotation_locations: typing.Optional[typing.Iterable[global___SourceLocation]] = ...,
        structured_annotations: typing.Optional[typing.Iterable[global___StructuredAnnotation]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["original_type",b"original_type","representation",b"representation","translated_type",b"translated_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_locations",b"annotation_locations","annotations",b"annotations","original_type",b"original_type","representation",b"representation","structured_annotations",b"structured_annotations","translated_type",b"translated_type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["representation",b"representation"]) -> typing.Optional[typing_extensions.Literal["original_type","translated_type"]]: ...
global___P4NewTypeSpec = P4NewTypeSpec
