"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
This package and its contents are a work-in-progress."""
import abc
import collections.abc
import grpc
import grpc.aio
from . import p4runtime_pb2 as _dot_p4runtime_pb2
import typing

_T = typing.TypeVar('_T')

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta):
    ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore
    ...

class P4RuntimeStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    Write: grpc.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.WriteRequest,
        _dot_p4runtime_pb2.WriteResponse,
    ]
    """Update one or more P4 entities on the target."""
    Read: grpc.UnaryStreamMultiCallable[
        _dot_p4runtime_pb2.ReadRequest,
        _dot_p4runtime_pb2.ReadResponse,
    ]
    """Read one or more P4 entities from the target."""
    SetForwardingPipelineConfig: grpc.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.SetForwardingPipelineConfigRequest,
        _dot_p4runtime_pb2.SetForwardingPipelineConfigResponse,
    ]
    """Sets the P4 forwarding-pipeline config."""
    GetForwardingPipelineConfig: grpc.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.GetForwardingPipelineConfigRequest,
        _dot_p4runtime_pb2.GetForwardingPipelineConfigResponse,
    ]
    """Gets the current P4 forwarding-pipeline config."""
    StreamChannel: grpc.StreamStreamMultiCallable[
        _dot_p4runtime_pb2.StreamMessageRequest,
        _dot_p4runtime_pb2.StreamMessageResponse,
    ]
    """Represents the bidirectional stream between the controller and the
    switch (initiated by the controller), and is managed for the following
    purposes:
    - connection initiation through client arbitration
    - indicating switch session liveness: the session is live when switch
      sends a positive client arbitration update to the controller, and is
      considered dead when either the stream breaks or the switch sends a
      negative update for client arbitration
    - the controller sending/receiving packets to/from the switch
    - streaming of notifications from the switch
    """
    Capabilities: grpc.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.CapabilitiesRequest,
        _dot_p4runtime_pb2.CapabilitiesResponse,
    ]

class P4RuntimeAsyncStub:
    Write: grpc.aio.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.WriteRequest,
        _dot_p4runtime_pb2.WriteResponse,
    ]
    """Update one or more P4 entities on the target."""
    Read: grpc.aio.UnaryStreamMultiCallable[
        _dot_p4runtime_pb2.ReadRequest,
        _dot_p4runtime_pb2.ReadResponse,
    ]
    """Read one or more P4 entities from the target."""
    SetForwardingPipelineConfig: grpc.aio.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.SetForwardingPipelineConfigRequest,
        _dot_p4runtime_pb2.SetForwardingPipelineConfigResponse,
    ]
    """Sets the P4 forwarding-pipeline config."""
    GetForwardingPipelineConfig: grpc.aio.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.GetForwardingPipelineConfigRequest,
        _dot_p4runtime_pb2.GetForwardingPipelineConfigResponse,
    ]
    """Gets the current P4 forwarding-pipeline config."""
    StreamChannel: grpc.aio.StreamStreamMultiCallable[
        _dot_p4runtime_pb2.StreamMessageRequest,
        _dot_p4runtime_pb2.StreamMessageResponse,
    ]
    """Represents the bidirectional stream between the controller and the
    switch (initiated by the controller), and is managed for the following
    purposes:
    - connection initiation through client arbitration
    - indicating switch session liveness: the session is live when switch
      sends a positive client arbitration update to the controller, and is
      considered dead when either the stream breaks or the switch sends a
      negative update for client arbitration
    - the controller sending/receiving packets to/from the switch
    - streaming of notifications from the switch
    """
    Capabilities: grpc.aio.UnaryUnaryMultiCallable[
        _dot_p4runtime_pb2.CapabilitiesRequest,
        _dot_p4runtime_pb2.CapabilitiesResponse,
    ]

class P4RuntimeServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def Write(
        self,
        request: _dot_p4runtime_pb2.WriteRequest,
        context: _ServicerContext,
    ) -> typing.Union[_dot_p4runtime_pb2.WriteResponse, collections.abc.Awaitable[_dot_p4runtime_pb2.WriteResponse]]:
        """Update one or more P4 entities on the target."""
    @abc.abstractmethod
    def Read(
        self,
        request: _dot_p4runtime_pb2.ReadRequest,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[_dot_p4runtime_pb2.ReadResponse], collections.abc.AsyncIterator[_dot_p4runtime_pb2.ReadResponse]]:
        """Read one or more P4 entities from the target."""
    @abc.abstractmethod
    def SetForwardingPipelineConfig(
        self,
        request: _dot_p4runtime_pb2.SetForwardingPipelineConfigRequest,
        context: _ServicerContext,
    ) -> typing.Union[_dot_p4runtime_pb2.SetForwardingPipelineConfigResponse, collections.abc.Awaitable[_dot_p4runtime_pb2.SetForwardingPipelineConfigResponse]]:
        """Sets the P4 forwarding-pipeline config."""
    @abc.abstractmethod
    def GetForwardingPipelineConfig(
        self,
        request: _dot_p4runtime_pb2.GetForwardingPipelineConfigRequest,
        context: _ServicerContext,
    ) -> typing.Union[_dot_p4runtime_pb2.GetForwardingPipelineConfigResponse, collections.abc.Awaitable[_dot_p4runtime_pb2.GetForwardingPipelineConfigResponse]]:
        """Gets the current P4 forwarding-pipeline config."""
    @abc.abstractmethod
    def StreamChannel(
        self,
        request_iterator: _MaybeAsyncIterator[_dot_p4runtime_pb2.StreamMessageRequest],
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[_dot_p4runtime_pb2.StreamMessageResponse], collections.abc.AsyncIterator[_dot_p4runtime_pb2.StreamMessageResponse]]:
        """Represents the bidirectional stream between the controller and the
        switch (initiated by the controller), and is managed for the following
        purposes:
        - connection initiation through client arbitration
        - indicating switch session liveness: the session is live when switch
          sends a positive client arbitration update to the controller, and is
          considered dead when either the stream breaks or the switch sends a
          negative update for client arbitration
        - the controller sending/receiving packets to/from the switch
        - streaming of notifications from the switch
        """
    @abc.abstractmethod
    def Capabilities(
        self,
        request: _dot_p4runtime_pb2.CapabilitiesRequest,
        context: _ServicerContext,
    ) -> typing.Union[_dot_p4runtime_pb2.CapabilitiesResponse, collections.abc.Awaitable[_dot_p4runtime_pb2.CapabilitiesResponse]]: ...

def add_P4RuntimeServicer_to_server(servicer: P4RuntimeServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
